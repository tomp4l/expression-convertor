// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Decode = require("bs-decode/./src/Decode.bs.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var CamlinternalLazy = require("bs-platform/lib/js/camlinternalLazy.js");
var Decode_AsResult_OfParseError = require("bs-decode/./src/Decode_AsResult_OfParseError.bs.js");

function fail(a, j) {
  return /* Error */Block.__(1, [/* Val */Block.__(0, [
                a,
                j
              ])]);
}

function matchString(s) {
  return Curry._2(Decode_AsResult_OfParseError.flatMap, (function (v, j) {
                if (v === s) {
                  return Curry._2(Decode_AsResult_OfParseError.pure, /* () */0, j);
                } else {
                  return /* Error */Block.__(1, [/* Val */Block.__(0, [
                                /* ExpectedValidOption */478520793,
                                j
                              ])]);
                }
              }), Decode_AsResult_OfParseError.string);
}

function operator(name, make) {
  return Curry._3(Decode_AsResult_OfParseError.Pipeline.field, "operator", matchString(name), Curry._1(Decode_AsResult_OfParseError.Pipeline.succeed, (function (param) {
                    return make;
                  })));
}

function outcomeDecoder(json) {
  return Curry._2(Decode_AsResult_OfParseError.Pipeline.run, json, Curry._3(Decode_AsResult_OfParseError.Pipeline.field, "value", Decode_AsResult_OfParseError.Pipeline.string, operator("outcome", (function (v) {
                        return /* Outcome */Block.__(0, [v]);
                      }))));
}

function calculatedCharacteristicDecoder(json) {
  return Curry._2(Decode_AsResult_OfParseError.Pipeline.run, json, Curry._3(Decode_AsResult_OfParseError.Pipeline.field, "name", Decode_AsResult_OfParseError.Pipeline.string, operator("calculated-characteristic", (function (name) {
                        return /* CalculatedCharacteristic */Block.__(1, [name]);
                      }))));
}

function longDecoder(json) {
  return Curry._2(Decode_AsResult_OfParseError.Pipeline.run, json, Curry._3(Decode_AsResult_OfParseError.Pipeline.field, "value", Decode_AsResult_OfParseError.Pipeline.string, operator("long", (function (name) {
                        return /* Long */Block.__(2, [name]);
                      }))));
}

function floatDecoder(json) {
  return Curry._2(Decode_AsResult_OfParseError.Pipeline.run, json, Curry._3(Decode_AsResult_OfParseError.Pipeline.field, "value", Decode_AsResult_OfParseError.Pipeline.string, operator("float", (function (name) {
                        return /* Float */Block.__(3, [name]);
                      }))));
}

function stringDecoder(json) {
  return Curry._3(Decode_AsResult_OfParseError.map, (function (v) {
                return /* String */Block.__(4, [v]);
              }), Decode_AsResult_OfParseError.string, json);
}

function characteristicDecoder(name, json) {
  return Curry._2(Decode_AsResult_OfParseError.Pipeline.run, json, Curry._3(Decode_AsResult_OfParseError.Pipeline.field, "characteristic", Decode_AsResult_OfParseError.Pipeline.string, Curry._3(Decode_AsResult_OfParseError.Pipeline.field, "data_source", Decode_AsResult_OfParseError.Pipeline.string, operator(name, (function (p, v) {
                            return /* Characteristic */Block.__(12, [
                                      p,
                                      v
                                    ]);
                          })))));
}

function stringCharacteristicDecoder(param) {
  return characteristicDecoder("string-characteristic", param);
}

function longCharacteristicDecoder(param) {
  return characteristicDecoder("long-characteristic", param);
}

var not = CamlinternalLazy.force;

function ifElseDecoder(json) {
  return Curry._2(Decode_AsResult_OfParseError.Pipeline.run, json, Curry._3(Decode_AsResult_OfParseError.Pipeline.field, "if_false", CamlinternalLazy.force(lazyExpressionDecoder), Curry._3(Decode_AsResult_OfParseError.Pipeline.field, "if_true", CamlinternalLazy.force(lazyExpressionDecoder), Curry._3(Decode_AsResult_OfParseError.Pipeline.field, "condition", CamlinternalLazy.force(lazyExpressionDecoder), operator("if-else", (function (c, l, r) {
                                return /* IfElse */Block.__(5, [
                                          c,
                                          l,
                                          r
                                        ]);
                              }))))));
}

function leftRightDecoder(name, make, json) {
  return Curry._2(Decode_AsResult_OfParseError.Pipeline.run, json, Curry._3(Decode_AsResult_OfParseError.Pipeline.field, "right", CamlinternalLazy.force(lazyExpressionDecoder), Curry._3(Decode_AsResult_OfParseError.Pipeline.field, "left", CamlinternalLazy.force(lazyExpressionDecoder), operator(name, make))));
}

function coalesceDecoder(json) {
  return Curry._2(Decode_AsResult_OfParseError.Pipeline.run, json, Curry._3(Decode_AsResult_OfParseError.Pipeline.field, "default", CamlinternalLazy.force(lazyExpressionDecoder), Curry._3(Decode_AsResult_OfParseError.Pipeline.field, "value", CamlinternalLazy.force(lazyExpressionDecoder), operator("coalesce", (function (v, $$default) {
                            return /* Coalesce */Block.__(14, [
                                      v,
                                      $$default
                                    ]);
                          })))));
}

function stripDecoder(json) {
  return Curry._2(Decode_AsResult_OfParseError.Pipeline.run, json, Curry._3(Decode_AsResult_OfParseError.Pipeline.field, "expression", CamlinternalLazy.force(lazyExpressionDecoder), operator("strip", (function (a) {
                        return /* Strip */Block.__(17, [a]);
                      }))));
}

function listDecoder(json) {
  return Curry._2(Decode_AsResult_OfParseError.Pipeline.run, json, Curry._3(Decode_AsResult_OfParseError.Pipeline.field, "items", Curry._1(Decode_AsResult_OfParseError.Pipeline.list, CamlinternalLazy.force(lazyExpressionDecoder)), operator("list", (function (l) {
                        return /* List */Block.__(18, [l]);
                      }))));
}

function rangeDecoder(json) {
  return Curry._2(Decode_AsResult_OfParseError.Pipeline.run, json, Curry._3(Decode_AsResult_OfParseError.Pipeline.optionalField, "to", CamlinternalLazy.force(lazyExpressionDecoder), Curry._3(Decode_AsResult_OfParseError.Pipeline.optionalField, "from", CamlinternalLazy.force(lazyExpressionDecoder), operator("range", (function (from, to_) {
                            return /* Range */Block.__(21, [
                                      from,
                                      to_
                                    ]);
                          })))));
}

function containsDecoder(json) {
  return Curry._2(Decode_AsResult_OfParseError.Pipeline.run, json, Curry._3(Decode_AsResult_OfParseError.Pipeline.field, "list", CamlinternalLazy.force(lazyExpressionDecoder), Curry._3(Decode_AsResult_OfParseError.Pipeline.field, "item", CamlinternalLazy.force(lazyExpressionDecoder), operator("contain", (function (a, b) {
                            return /* Contains */Block.__(16, [
                                      a,
                                      b
                                    ]);
                          })))));
}

function mapDecoder(json) {
  return Curry._2(Decode_AsResult_OfParseError.Pipeline.run, json, Curry._3(Decode_AsResult_OfParseError.Pipeline.field, "value", Curry._1(Decode_AsResult_OfParseError.Pipeline.list, (function (j) {
                        return Curry._2(Decode_AsResult_OfParseError.Pipeline.run, j, Curry._3(Decode_AsResult_OfParseError.Pipeline.field, "value", CamlinternalLazy.force(lazyExpressionDecoder), Curry._3(Decode_AsResult_OfParseError.Pipeline.field, "key", CamlinternalLazy.force(lazyExpressionDecoder), Curry._1(Decode_AsResult_OfParseError.Pipeline.succeed, (function (a, b) {
                                                  return /* tuple */[
                                                          a,
                                                          b
                                                        ];
                                                })))));
                      })), operator("map", (function (l) {
                        return /* Map */Block.__(20, [l]);
                      }))));
}

function lookupDecoder(json) {
  return Curry._2(Decode_AsResult_OfParseError.Pipeline.run, json, Curry._3(Decode_AsResult_OfParseError.Pipeline.field, "map", CamlinternalLazy.force(lazyExpressionDecoder), Curry._3(Decode_AsResult_OfParseError.Pipeline.field, "key", CamlinternalLazy.force(lazyExpressionDecoder), operator("lookup", (function (k, m) {
                            return /* Lookup */Block.__(19, [
                                      k,
                                      m
                                    ]);
                          })))));
}

function valueDecoder(name, make, json) {
  return Curry._2(Decode_AsResult_OfParseError.Pipeline.run, json, Curry._3(Decode_AsResult_OfParseError.Pipeline.field, "value", CamlinternalLazy.force(lazyExpressionDecoder), operator(name, make)));
}

var lazyExpressionDecoder = Caml_obj.caml_lazy_make((function (param) {
        return Curry._2(Decode_AsResult_OfParseError.oneOf, outcomeDecoder, /* :: */[
                    stringDecoder,
                    /* :: */[
                      stringCharacteristicDecoder,
                      /* :: */[
                        longCharacteristicDecoder,
                        /* :: */[
                          ifElseDecoder,
                          /* :: */[
                            (function (param) {
                                return valueDecoder("str-to-long", (function (v) {
                                              return /* ToLong */Block.__(13, [v]);
                                            }), param);
                              }),
                            /* :: */[
                              (function (param) {
                                  return valueDecoder("is-defined", (function (v) {
                                                return /* IsDefined */Block.__(15, [v]);
                                              }), param);
                                }),
                              /* :: */[
                                (function (param) {
                                    return valueDecoder("not", (function (v) {
                                                  return /* Not */Block.__(9, [v]);
                                                }), param);
                                  }),
                                /* :: */[
                                  (function (param) {
                                      return valueDecoder("float-to-long", (function (v) {
                                                    return /* ToLong */Block.__(13, [v]);
                                                  }), param);
                                    }),
                                  /* :: */[
                                    calculatedCharacteristicDecoder,
                                    /* :: */[
                                      longDecoder,
                                      /* :: */[
                                        (function (param) {
                                            return leftRightDecoder("less-than-or-equals", (function (l, r) {
                                                          return /* Comparison */Block.__(6, [
                                                                    "<=",
                                                                    l,
                                                                    r
                                                                  ]);
                                                        }), param);
                                          }),
                                        /* :: */[
                                          (function (param) {
                                              return leftRightDecoder("greater-than-or-equals", (function (l, r) {
                                                            return /* Comparison */Block.__(6, [
                                                                      ">=",
                                                                      l,
                                                                      r
                                                                    ]);
                                                          }), param);
                                            }),
                                          /* :: */[
                                            (function (param) {
                                                return leftRightDecoder("less-than", (function (l, r) {
                                                              return /* Comparison */Block.__(6, [
                                                                        "<",
                                                                        l,
                                                                        r
                                                                      ]);
                                                            }), param);
                                              }),
                                            /* :: */[
                                              (function (param) {
                                                  return leftRightDecoder("greater-than", (function (l, r) {
                                                                return /* Comparison */Block.__(6, [
                                                                          ">",
                                                                          l,
                                                                          r
                                                                        ]);
                                                              }), param);
                                                }),
                                              /* :: */[
                                                (function (param) {
                                                    return leftRightDecoder("equals", (function (l, r) {
                                                                  return /* Comparison */Block.__(6, [
                                                                            "==",
                                                                            l,
                                                                            r
                                                                          ]);
                                                                }), param);
                                                  }),
                                                /* :: */[
                                                  (function (param) {
                                                      return leftRightDecoder("not-equals", (function (l, r) {
                                                                    return /* Comparison */Block.__(6, [
                                                                              "!=",
                                                                              l,
                                                                              r
                                                                            ]);
                                                                  }), param);
                                                    }),
                                                  /* :: */[
                                                    coalesceDecoder,
                                                    /* :: */[
                                                      (function (param) {
                                                          return leftRightDecoder("or", (function (l, r) {
                                                                        return /* Or */Block.__(7, [
                                                                                  l,
                                                                                  r
                                                                                ]);
                                                                      }), param);
                                                        }),
                                                      /* :: */[
                                                        (function (param) {
                                                            return leftRightDecoder("and", (function (l, r) {
                                                                          return /* And */Block.__(8, [
                                                                                    l,
                                                                                    r
                                                                                  ]);
                                                                        }), param);
                                                          }),
                                                        /* :: */[
                                                          (function (param) {
                                                              return leftRightDecoder("plus", (function (l, r) {
                                                                            return /* Plus */Block.__(10, [
                                                                                      l,
                                                                                      r
                                                                                    ]);
                                                                          }), param);
                                                            }),
                                                          /* :: */[
                                                            (function (param) {
                                                                return leftRightDecoder("times", (function (l, r) {
                                                                              return /* Times */Block.__(11, [
                                                                                        l,
                                                                                        r
                                                                                      ]);
                                                                            }), param);
                                                              }),
                                                            /* :: */[
                                                              containsDecoder,
                                                              /* :: */[
                                                                stripDecoder,
                                                                /* :: */[
                                                                  listDecoder,
                                                                  /* :: */[
                                                                    mapDecoder,
                                                                    /* :: */[
                                                                      floatDecoder,
                                                                      /* :: */[
                                                                        lookupDecoder,
                                                                        /* :: */[
                                                                          rangeDecoder,
                                                                          /* [] */0
                                                                        ]
                                                                      ]
                                                                    ]
                                                                  ]
                                                                ]
                                                              ]
                                                            ]
                                                          ]
                                                        ]
                                                      ]
                                                    ]
                                                  ]
                                                ]
                                              ]
                                            ]
                                          ]
                                        ]
                                      ]
                                    ]
                                  ]
                                ]
                              ]
                            ]
                          ]
                        ]
                      ]
                    ]
                  ]);
      }));

function comparisonDecoder(op, sym) {
  return (function (param) {
      return leftRightDecoder(op, (function (l, r) {
                    return /* Comparison */Block.__(6, [
                              sym,
                              l,
                              r
                            ]);
                  }), param);
    });
}

var expressionDecoder = CamlinternalLazy.force(lazyExpressionDecoder);

var Decode$1 = 0;

exports.Decode = Decode$1;
exports.fail = fail;
exports.matchString = matchString;
exports.operator = operator;
exports.outcomeDecoder = outcomeDecoder;
exports.calculatedCharacteristicDecoder = calculatedCharacteristicDecoder;
exports.longDecoder = longDecoder;
exports.floatDecoder = floatDecoder;
exports.stringDecoder = stringDecoder;
exports.characteristicDecoder = characteristicDecoder;
exports.stringCharacteristicDecoder = stringCharacteristicDecoder;
exports.longCharacteristicDecoder = longCharacteristicDecoder;
exports.not = not;
exports.ifElseDecoder = ifElseDecoder;
exports.valueDecoder = valueDecoder;
exports.leftRightDecoder = leftRightDecoder;
exports.comparisonDecoder = comparisonDecoder;
exports.coalesceDecoder = coalesceDecoder;
exports.containsDecoder = containsDecoder;
exports.stripDecoder = stripDecoder;
exports.listDecoder = listDecoder;
exports.lookupDecoder = lookupDecoder;
exports.mapDecoder = mapDecoder;
exports.rangeDecoder = rangeDecoder;
exports.lazyExpressionDecoder = lazyExpressionDecoder;
exports.expressionDecoder = expressionDecoder;
/* expressionDecoder Not a pure module */
